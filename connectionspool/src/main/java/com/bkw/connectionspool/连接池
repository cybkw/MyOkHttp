连接池作用------->缓解服务器压力

责任链模式
分发器-->重试拦截器-->请求头处理拦截器-->网络连接拦截器（每次都创建连接）

在网络连接拦截器中复用请求，避免创建相同的链接。

为什么OkHttp是高效的网络请求框架？
因为开发者自己封装了Socket,原始化，复用socket,缓存机制，多种拦截器模式。

1.HttpURLConnection跟Socket的区别？
HTTP HTTPS HttpUrlConnection都是在应用层。
而Socket属于TCP/IP传输层。

2.复用池使用什么样的数据结构？
使用双端队列集合模式。 Dequeue<?> lists;

3.SynchronousQueue和LinkedBlockingQueue队列区别？
前者，线程安全的，是一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作。
所以，当我们提交第一个任务的时候，是加入不了队列的，这就满足了，
一个线程池条件“当无法加入队列的时候，且任务没有达到maxsize时，
我们将新开启一个线程任务”。所以我们的maxsize是big big。时间是60s，
当一个线程没有任务执行会暂时保存60s超时时间，如果没有的新的任务的话，会从cache中remove掉。

LinkedBlockingQueue：
LinkedBlockingQueue是无界的，是一个无界缓存的等待队列。
基于链表的阻塞队列，内部维持着一个数据缓冲队列（该队列由链表构成）。
当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，
而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue可以通过构造函数指定该值）
，才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，
反之对于消费者这端的处理也基于同样的原理。LinkedBlockingQueue之所以能够高效的处理并发数据，
还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，
这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。

ArrayBlockingQueue：
ArrayListBlockingQueue是有界的，是一个有界缓存的等待队列。
基于数组的阻塞队列，同LinkedBlockingQueue类似，内部维持着一个定长数据缓冲队列（该队列由数组构成）。
ArrayBlockingQueue内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置。
ArrayBlockingQueue在生产者放入数据和消费者获取数据，都是共用同一个锁对象，
由此也意味着两者无法真正并行运行，这点尤其不同于LinkedBlockingQueue；
按照实现原理来分析，ArrayBlockingQueue完全可以采用分离锁，从而实现生产者和消费者操作的完全并行运行。
Doug Lea之所以没这样去做，也许是因为ArrayBlockingQueue的数据写入和获取操作已经足够轻巧，
以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。
ArrayBlockingQueue和LinkedBlockingQueue间还有一个明显的不同之处在于，
前者在插入或删除元素时不会产生或销毁任何额外的对象实例，而后者则会生成一个额外的Node对象。
这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC的影响还是存在一定的区别。

